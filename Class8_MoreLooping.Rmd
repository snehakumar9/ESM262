---
title: "More Looping and Control Structures"
author: "Naomi Tague"
date: "January, 2025"
output:
  slidy_presentation:
    highlight: pygments
  html_document: default
  pdf_document: default
  ioslides_presentation:
    highlight: pygments
  beamer_presentation:
    highlight: pygments
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo =TRUE)
knitr::opts_chunk$set(error=TRUE)

library(tidyverse)
library(purrr)
library(ggpubr)
```

#  Questions about For loops
# Another Example

Recall our annual yield of a crop function:


$$ yield =  1.8*fertilizer^2 - 0.5*fertilizer  + 0.1*TP $$


and TP is mean precipitation in cm


 Use a *for* loop to estimate the total yield after 10 years if

  * fertilizer is normally distributed with mean of 5 and standard deviation of 0.5
  * TP is 20cm
  

# Do on your own first before you check with this

```{r cropyield}

fert = rnorm(n=10, mean=5, sd=0.5)
TP = 20

crop = data.frame(fert=fert)
crop$yield = NA
for (yr in 1:10) {
  crop$yield[yr] = 1.8*fert[yr]^2 - 0.5*fert[yr]  + 0.1*TP
}

sum(crop$yield)
ggplot(crop, aes(fert, yield))+geom_point()+labs(y="yield", x="fertilizer")

# as a function

compute_yield = function(fert, TP) {
  yield = 1.8*fert^2-0.5* fert + 0.1*TP
  return(yield)
}

# apply function
compute_yield(fert, TP)
sum(compute_yield(fert, TP))

```




# Some other types of loops

* for
  useful for repeating a set number of times (i in 1:n)
* while
  useful for repeating until a condition is met

Example
if a metal toxin in a lake increases by 1% per year, how many years will it take for the metal level to be greater than 30 units, if toxin is current at 5 units


```{r} 

# accumulate pollutant until a threshold - how many years does it take

# initial conditions
yr=1
pollutant_level = 5

# loop
while ((pollutant_level < 30) &&(yr < 1000))  {
  # increase pollutant
pollutant_level = pollutant_level + 0.01* pollutant_level 
# keep track of time
yr = yr + 1
}

pollutant_level
yr

```

# While Loops

Other examples?

What's wrong with this code

```{r, eval=FALSE}
while ((pollutant_level < 30))  {
  # increase pollutant
pollutant_level = pollutant_level - 0.01* pollutant_level 
}
```



# What we've learned

* how to write a function (and add error checking)
* how to generate data
* how to repeat in code  (different types of looping)



# A more complex example of looping in R

Lets **scale** up from a single car to a group of cars on a highway
and use our **autopower** function to estimate a distribution of power 

What might vary?

# Our highway

3 car types 

Imagine with have 3 different car types - and we know how often each occurs:

* car A  mass 20000 kg, area 22 m^2^

* car B mass 65000 kg, area 30 m^2^

* car C mass 38000 kg area 22 m^2^

Mean highway speed is 100 km/hr 


```{r sampling2, eval=TRUE, echo=TRUE}

source("../R/autopower.R")
# generate a structure to store info on our possible cars
possible_cars = data.frame(name = c("A","B","C"),mass=c(10000,65000,38000), area = c(22,30,22))

# first look at how results vary for mean speed say 100km/hr
# do conversion
speed_base = 100 * 0.28

# because I have one mass and area for each car and only 1 speed
# I can estimate power for each car type
# add to the data structure
possible_cars$power = autopower(V=speed_base, A = possible_cars$area, m=possible_cars$mass)

head(possible_cars)

# show results                         
ggplot(possible_cars, aes(x=mass, y=power, fill=as.factor(area)))+geom_col()+labs(y="Power W", x="Mass (kg)", fill="Area (m2)")
  

```

# Building a highway

What could be the total power consumed if there are 200 cars on this highway each hour,
they are travelling at a range of speeds - mean is 100km/hr and speeds tend to
be log-normally distributed)

How would the total power consumed vary by car
So if all cars are car A; OR all cars are car B OR all cars are car C

We will use *sample* here to generate speeds for our 100 cars and look at different ways to
repeat power calculation for different cars

* repeating by hand
* *for* for repetition - a more standard way of looping available in many langugaes
* *pmap* for repetition - a efficient way of looping in R

# First lets do it 'by hand'

```{r byhand}

# what is I want to estimate average power use given  each car

possible_cars

# use sample to generate a distribution of speeds

# assume a log normal distribution of speeds with mean 100km/hr, and standard deviation that is 10% of the mean

# recall our function needs speed in m/s not km/hr so we will also do a conversion
# lets get a sample of a 200 speeds- we could also do this by actually measuring speeds

nsample = 200
mean_speed = log(100*0.277)

speeds = rlnorm(mean=mean_speed, sd=0.1*mean_speed, nsample)
summary(speeds)

plot(density(speeds), ylab="Distribution of Speeds in (m/s)")


# how do we run each car for all speeds 

# first lets to it by hand for the first car - the first row in our possible cars matrix
possible_cars[1,]

# we could do it by hand
powerA = autopower(V=speeds, A = possible_cars$area[1], m=possible_cars$mass[1])
# lets look at what we get
summary(powerA)

# next car (row 2)
powerB = autopower(V=speeds, A = possible_cars$area[2], m=possible_cars$mass[2])
# lets look at what we get
summary(powerB)

# next car (row 3)
powerC = autopower(V=speeds, A = possible_cars$area[3], m=possible_cars$mass[3])
# lets look at what we get
summary(powerC)


# we could put this together
powerall1 = cbind.data.frame(powerA, powerB, powerC)
colnames(powerall1)=possible_cars$name


# for plotting sometimes its useful to turn columns in to rows - we can use an R function
# called pivot_longer (part of the tidyverse package) to do this
# compare powerall1 and powerallr1 to see what pivot_longer does
powerallr1 = powerall1 %>% pivot_longer(cols=everything(), names_to="car", values_to="power")
head(powerallr1)

# quick visualization
# lets save it so that we can compare
method1_plot = ggplot(powerallr1, aes(car,power, fill=car))+geom_boxplot()+ggtitle("By Hand")
method1_plot



```


# Second- classic looping *for*
Doing this by hand would be hard if we had many different cars - can we automate?

YES

For loop


Lets do this one more time using a *for* loop

```{r withforloop}

# the first part, generating speeds is the same
# what is I want to estimate average power use given  each car

possible_cars


# how do we run each car for all speeds 
# we use a for loop to cycle through
# we need to create a data frame to store results - as above
# one column for each car and one row for each speed

powerall2 = as.data.frame(matrix(nrow=length(speeds), ncol=nrow(possible_cars)))
# because we don't initialize it - values are NA
head(powerall2)

# how many cars area there
nrow(possible_cars)
ncol(powerall2)
# for loops use an index - in this case "i" but you could use anything - it repeats
# anything between the {} for each values of i between 1 and nrow(possible_car) (which is 3 in our case)

# index in to a matrix (like powerall3) is by row and column powerall3[2,5] is 2nd row and 5th column
for (i in 1:ncol(powerall2)) {
  powerall2[,i] = autopower(A=possible_cars$area[i], m=possible_cars$mass[i], V=speeds)
}

# now it looks like above
head(powerall2)
# we can add column names
colnames(powerall2)=possible_cars$name

# plotting is the same as above

# for plotting sometimes its useful to turn columns in to rows
powerallr2 = powerall2 %>% pivot_longer(cols=everything(), names_to="car", values_to="power")
head(powerallr2)

# quick visualization
method2_plot = ggplot(powerallr2, aes(car,power, fill=car))+geom_boxplot()+ggtitle("For Loop")

ggarrange(method1_plot, method2_plot, nrow=2)

powerall1 %>% map(mean)
powerall2 %>% map(mean)

```

# Third using R built in tools

*pmap* works quickly but it is unique to R
Other programming language (and R) use what are called loops - where repetition is more explicit



*pmap* is available in the *purr* library

*mapply* is another R option


*pmap*
- runs a function for a list of parameters
- using other parameters for each iteration


```{r withpmap}



# how do we run each car for all speeds 
# pmap runs a function for each value in a list of parameters, with other parameters set for each iteration


powerall3 = pmap(list(A = possible_cars$area, m=possible_cars$mass), autopower, V=speeds)

# lets turn to a data frame for easier graphing
# we can add column names
powerall3 = as.data.frame(powerall2, col.names=possible_cars$name)

head(powerall3)


# for plotting sometimes its useful to turn columns in to rows
powerallr3 = powerall3 %>% pivot_longer(cols=everything(), names_to="car", values_to="power")
head(powerallr2)

# quick visualization

method3_plot = ggplot(powerallr3, aes(car,power, fill=car))+geom_boxplot()+ggtitle("pmap")
method3_plot

# put plots side by side
# to confirm that they look similar
ggarrange(method1_plot, method2_plot, method3_plot, nrow=3)

# compare values
head(powerallr2)
head(powerallr1)
head(powerallr3)


```

# Assignment 4

For this assignment you will write a new Quartro document based on the analysis of power required for different *possible_cars* from looping.RMD; You will

* Add an additional super light car with mass 5,000 kg and a surface area 10m2

* Compute the mean and maximum power for Cars A, B, C and for your new car, assuming that average highway speed is 80 km/hr with a standard deviation of 10km/hr;  Use 2 different methods to compute the mean and maximum power for each car type; a) **FOR** loop and b) the **pmap** function from **purr**

* Create two boxplots (one for each method (**FOR** and **pmap**)) that show the range of power consumption (across sampled speeds) for each car type.

Put the Quatro in your assignment github and submit a link on Canvas for Assignment 4 when its ready to be graded

**Grading Rubric**

1. Correct R code for adding the super light car (5pts)
2. Values for mean and maximum power for all 4 cars are in expected ranges (remember you are sampling so values will differ slightly) (5pts)
3. Used both methods (**FOR** and **pmap**) correctly (4pts)
4. Boxplots (6pts)
  a) correctly show range of power consumption for each car type for the two methdos
  b) good presentation (e.g axis labels, colors)
5. Good coding practice (e.g Adequate documentation throughout) (5pts)

Total out of 25pts



