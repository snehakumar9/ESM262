---
title: "Data Types"
author: "Naomi Tague"
date: "January, 2025"
output:
  slidy_presentation:
    highlight: pygments
  html_document: default
  pdf_document: default
  ioslides_presentation:
    highlight: pygments
  beamer_presentation:
    highlight: pygments
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo =TRUE)
knitr::opts_chunk$set(error=TRUE)

library(tidyverse)
library(purrr)

```
# <span style="color:orange"> What we've learned

* how to write a function (and add error checking)
* how to generate data
* how to repeat in code  (different types of looping)


Today

* Data Types ( data you use in functions and loops)


# <span style="color:orange"> Data types 

All programming languages use data-types, or structures to hold information

* integer
* floating point/ real / numeric
* character 
* string

Often data types are multi-dimensional 
Some useful ones in R

* vector
* matrix
* data frame
* factors
* lists

Programming often involves selecting and building data structures. Like the  matrix we built last class to hold the results from our **for** loop

Good data structures are

* as simple as possible
* easy to understand (readable names)
* easy to manipulate 
* easy to visualize

# <span style="color:orange"> Factors \span

something that has different **classes** or **groups**
useful for doing calculations with categories

Here's an example:

First lets look at a standard numeric vector

```{r} 
a = c(1.3, 1, 4, 1.3, 22,3)
# compute the mean
mean(a)
```

What if **a** is a factor

What do commands like **mean** do
```{r} 
a = as.factor(a)
# compute the mean
mean(a)

#why? lets look
a

```
# <span style="color:orange"> Factors - Fishing Example \span


Lets imagine that we recording fish catches 

We will simulate this by sampling from a list of possible fish


We can use **summary** with factors to get frequencies in each category (or “level” )

```{r, catch, echo=TRUE}

# create vector of possible fish 
possible.fish = c("salmon","steelhead","shark","tuna","cod")

# we can use sample to simulate a random recording of catch by fisherman, lets say we pick 20 fish from the net

catch1 = base::sample(possible.fish, size=20, replace=T)
# because possible.fish was a factor catch1 will be a factor
catch1

summary(catch1)



# if we want summary to be more useful - make this a factor
catch1 = as.factor(catch1)


# to quickly get frequencies of different fish and to plot 
summary(catch1)
plot(catch1, col="orange")


# we can also use summary to explore and return information about the distribution
# mean frequency of a particular type of fish
mean(summary(catch1))

# maximum frequency
max(summary(catch1))

# which fish was most frequently caught
which.max(summary(catch1))

#to get just the name 
names(which.max(summary(catch1)))

ggplot(data.frame(catch1=catch1), aes(catch1, fill=catch1))+geom_histogram(stat="count")

```

How do we determine the rarest fish in the ocean?



# <span style="color:orange"> Functions with factors 

Lets generate a function that makes use of categorical data
species diversity is a good example

Simpson's Index (D) measures the probability that two individuals randomly selected from a sample will belong to the same species 

Value is between 0 and 1, with higher values associated with *lower* diversity so often transform

1-D is often used


See 
[Simpson Biodiversity](http://www.countrysideinfo.co.uk/simpsons.htm)


```{r diversity, echo=TRUE}

# lets create our ocean 

possible.fish = as.factor(c("salmon","steelhead","shark","tuna","cod"))

# simulate a random recording of catch by fisher
catch1 = sample(possible.fish, size=10, prob = c(0.2, 0.2, 0.1, 0.1, 0.4), replace=T)
summary(catch1)


# you can access each frequency.   
summary(catch1)[1]

source("../R/compute_simpson_index.R")
compute_simpson_index

compute_simpson_index(catch1)


```

Try to create a sample catch that has lower diversity

# <span style="color:orange"> Low diversity answer
```{r lowdiversity, echo=TRUE}
# lets create a test case that should have low diversity, by repeating the same thing
catch2 = c(rep("salmon", times=10), rep("cod", times=10))

compute_simpson_index(catch1)
compute_simpson_index(catch2)

```

# <span style="color:orange"> Some additional pointers


Sometimes you don't want factors and R thinks something should be


How can we change back? **as.numeric** makes sense ...but



```{r, convert, echo=TRUE}

a = as.factor(c(1.3, 1, 4, 1.3, 22))
#sum(a)

# try to make a numeric version from the factor
b = as.numeric(a)
sum(b)
b

# better
b = as.character(a)
b = as.numeric(b)
b
sum(b)
```

# <span style="color:orange">Sprintf Command - Making strings with different data types

some useful syntax if you want to generate strings

```{r}

tmp = "percent"
sprintf("Makes a string that includes text and data, For example  %d %s", 100, tmp)

```

* **%s** replace with a string
* **%d** replace with an integer value
* **%f** replace with a real value
* **%4.1f** replace with a real value with 4 digist, two after decimal
* **\\n** add a line return

Example

make a string with **sprintf** and add to plot title

lets say we wanted a title based on our most frequently caught fish 

Title of "We mostly caught *salmon*, (total was *10*)"
```{r fishes}

# substitute most frequent fish and total catch into a string
plottitle=sprintf("We mostly caught %s \n max catch(%d)", names(which.max(summary(catch1))), max(summary(catch1)))

# use string in a title
ggplot(data.frame(catch1=catch1), aes(catch1, fill=catch1))+geom_histogram(stat="count")+labs(title=plottitle)


```

#  <span style="color:orange"> Returning multiple things from a function \span

In R, to do this we use LISTS

* Lists are the most “informal” data structures in R
* List are really useful for keeping track of and organizing groups of things that are not all the same
* A list could be a table where number of rows is different for each column
* A list can have numeric, character, factors all mixed together
* List are often used for returning more complex information from function (e.g. lm)

```{r introlist, echo=TRUE}

# make a list
sale = list(id=2, quality="high", contents=c("apple","cherry"), cost=c(4,5))
sale

#ways to access elements
sale$id
sale$contents

# you can also access by list item number
# the [x] denotes the xth item in the list
sale[[3]]
sale[["contents"]]


# how do you get the second element in the vector that has the contents
# there are two ways


# add to a list
sale$location = "Farmers market"
sale
# or remove
sale$location = NULL
sale

# some tricky things
# correct accessing items in list
sale$cost
sale[[4]]

# works but
#sale[4]


sum(sale$cost)
sum(sale[[4]])

```


# <span style="color:orange">Using lists to return multiple items from a function

We can use *lists* to return multiple,diverse pieces of information from our functions
Lets start with diversity - many be want to know a bit more about the dataset

* Simpson diversity
* Most frequent species
* Number of distinct species



```{r, diversitylist, echo=TRUE}

# repeat with a list
source("../R/computediversity.R")

computediversity

computediversity(catch1)
computediversity(catch2)
```


# <span style="color:orange">Another example

Two more ideas

* how to have flow control with multiple choices
* how to include user choices in functions

We can also allow the user to make choices about what to return

Take a look at *compute_seasin_meanflow*

Questions?

```{r str, echo=TRUE}

source("../R/compute_season_meanflow.R")
compute_season_flow

str = read.table("../data/str.txt", header=T)
compute_season_flow(str)

compute_season_flow(str, kind="max")
```

# <span style="color:orange">What you've learned

* common data types
* returning multiple items from a function


# REVIEW for next class

* testing.RMD

# Last Assignment! 

For this assignment work in *pairs* - and submit as a group

* Design a function - you can pick any subject and you can even make up the equations as long as they conceptually make sense
  * Make sure it has at least 2 inputs and 1 parameter (ideally more) and at least 2 outputs
  * Code your function in R, save as a R file in subdirectory called R
  * Make sure you include documentation (both at the top as we've shown in past examples, and inline)
  * Include some error checking

* In an Quatro file, generate some data for 2 of the function inputs
  * use a *for*  loop to run the function for the data
  * repeat the "looping" using something from the "purrr" package 
  * Graph results (you can decide what the most interesting way to graph - you just need to make one graph)

* Write at least 2 tests for your function; store in a separate test file

* Put this in a git repo that includes an R subdirectory, a tests subsdirectory and your Quatro file and submit the link on Canvas (you can put all of this in a new git repo or a subdirectory of an existing git repo)

Submit the link to repo on Canvas (and name of subdirectory if part of a larger git project) as a group with your partner,



*Grading Rubric*

* Created a function 
  * at least 2 inputs, 1 parameter and 2 outputs (it can have more) (5pts)
  * includes error checking (5 pts)

* Quatro file that generates test data and runs the function
  * data generation ( 5pts)
  * run function multiple times with a loop (5 pts)
  * run function multiple times with something from *purr* (pmap) (5pts)
  * Graphs results (5 pts)

* Test file
  * a file with two tests (10pts)

Good programming practices (10 pts)
Total 50pts

